var Pinia=function(O,R){"use strict";let l;const S=t=>l=t,d=Symbol();function w(t){return t&&"object"==typeof t&&"[object Object]"===Object.prototype.toString.call(t)&&"function"!=typeof t.toJSON}O.MutationType=void 0,(e=O.MutationType||(O.MutationType={})).direct="direct",e.patchObject="patch object",e.patchFunction="patch function";const n="undefined"!=typeof window,P=()=>{};function V(e,n,t,i=P){e.push(n);var r=()=>{var t=e.indexOf(n);-1<t&&(e.splice(t,1),i())};return!t&&R.getCurrentScope()&&R.onScopeDispose(r),r}function k(t,...e){t.slice().forEach(t=>{t(...e)})}function M(n,t){n instanceof Map&&t instanceof Map&&t.forEach((t,e)=>n.set(e,t)),n instanceof Set&&t instanceof Set&&t.forEach(n.add,n);for(const r in t){var e,i;t.hasOwnProperty(r)&&(e=t[r],i=n[r],n[r]=w(i)&&w(e)&&n.hasOwnProperty(r)&&!R.isRef(e)&&!R.isReactive(e)?M(i,e):e)}return n}const A=Symbol(),T=new WeakMap,E=Object["assign"];function y(a,t,n={},o,e,i){let r;const s=E({actions:{}},n),c={deep:!0};let u,p,f,h=R.markRaw([]),l=R.markRaw([]);var d=o.state.value[a];let y;function v(t){let e;u=p=!1,e="function"==typeof t?(t(o.state.value[a]),{type:O.MutationType.patchFunction,storeId:a,events:f}):(M(o.state.value[a],t),{type:O.MutationType.patchObject,payload:t,storeId:a,events:f});const n=y=Symbol();R.nextTick().then(()=>{y===n&&(u=!0)}),p=!0,k(h,e,o.state.value[a])}i||d||(R.isVue2?R.set(o.state.value,a,{}):o.state.value[a]={}),R.ref({});var $,b=i?function(){const t=n["state"],e=t?t():{};this.$patch(t=>{E(t,e)})}:P;function _(r,s){return function(){S(o);const t=Array.from(arguments),e=[],n=[];let i;k(l,{args:t,name:r,store:g,after:function(t){e.push(t)},onError:function(t){n.push(t)}});try{i=s.apply(this&&this.$id===a?this:g,t)}catch(t){throw k(n,t),t}return i instanceof Promise?i.then(t=>(k(e,t),t)).catch(t=>(k(n,t),Promise.reject(t))):(k(e,i),i)}}const j={_p:o,$id:a,$onAction:V.bind(null,l),$patch:v,$reset:b,$subscribe(e,n={}){const t=V(h,e,n.detached,()=>i()),i=r.run(()=>R.watch(()=>o.state.value[a],t=>{("sync"===n.flush?p:u)&&e({storeId:a,type:O.MutationType.direct,events:f},t)},E({},c,n)));return t},$dispose:function(){r.stop(),h=[],l=[],o._s.delete(a)}},g=(R.isVue2&&(j._r=!1),R.reactive(j)),m=(o._s.set(a,g),o._e.run(()=>(r=R.effectScope()).run(()=>t())));for(const O in m){const S=m[O];if(R.isRef(S)&&(!R.isRef($=S)||!$.effect)||R.isReactive(S))i||(!d||($=S,R.isVue2?T.has($):w($)&&$.hasOwnProperty(A))||(R.isRef(S)?S.value=d[O]:M(S,d[O])),R.isVue2?R.set(o.state.value[a],O,S):o.state.value[a][O]=S);else if("function"==typeof S){const a=_(O,S);R.isVue2?R.set(m,O,a):m[O]=a,s.actions[O]=S}}return R.isVue2?Object.keys(m).forEach(t=>{R.set(g,t,m[t])}):(E(g,m),E(R.toRaw(g),m)),Object.defineProperty(g,"$state",{get:()=>o.state.value[a],set:e=>{v(t=>{E(t,e)})}}),R.isVue2&&(g._r=!0),o._p.forEach(t=>{E(g,r.run(()=>t({store:g,app:o._a,pinia:o,options:s})))}),d&&i&&n.hydrate&&n.hydrate(g.$state,d),u=!0,p=!0,g}let i="Store";function t(i,r){return Array.isArray(r)?r.reduce((t,e)=>(t[e]=function(){return i(this.$pinia)[e]},t),{}):Object.keys(r).reduce((t,n)=>(t[n]=function(){const t=i(this.$pinia),e=r[n];return"function"==typeof e?e.call(this,t):t[e]},t),{})}var e=t;return O.PiniaVuePlugin=function(t){t.mixin({beforeCreate(){const e=this.$options;if(e.pinia){const t=e.pinia;if(!this._provided){const e={};Object.defineProperty(this,"_provided",{get:()=>e,set:t=>Object.assign(e,t)})}this._provided[d]=t,this.$pinia||(this.$pinia=t),t._a=this,n&&S(t)}else!this.$pinia&&e.parent&&e.parent.$pinia&&(this.$pinia=e.parent.$pinia)},destroyed(){delete this._pStores}})},O.acceptHMRUpdate=function(t,e){return()=>{}},O.createPinia=function(){const t=R.effectScope(!0),e=t.run(()=>R.ref({}));let n=[],i=[];const r=R.markRaw({install(t){S(r),R.isVue2||((r._a=t).provide(d,r),t.config.globalProperties.$pinia=r,i.forEach(t=>n.push(t)),i=[])},use(t){return(this._a||R.isVue2?n:i).push(t),this},_p:n,_a:null,_e:t,_s:new Map,state:e});return r},O.defineStore=function(t,u,e){let p,f;const h="function"==typeof u;function n(t,e){var n=R.getCurrentInstance();if((t=t||n&&R.inject(d,null))&&S(t),!(t=l)._s.has(p))if(h)y(p,u,f,t);else{var i=p,r=(n=f,t);const{state:s,actions:a,getters:o}=n,c=r.state.value[i];y(i,function(){c||(R.isVue2?R.set(r.state.value,i,s?s():{}):r.state.value[i]=s?s():{});var t=R.toRefs(r.state.value[i]);return E(t,a,Object.keys(o||{}).reduce((t,e)=>(t[e]=R.markRaw(R.computed(()=>{S(r);var t=r._s.get(i);if(!R.isVue2||t._r)return o[e].call(t,t)})),t),{}))},n,r,0,!0)}return t._s.get(p)}return"string"==typeof t?(p=t,f=h?e:u):(f=t,p=t.id),n.$id=p,n},O.getActivePinia=()=>R.getCurrentInstance()&&R.inject(d)||l,O.mapActions=function(n,i){return Array.isArray(i)?i.reduce((t,e)=>(t[e]=function(...t){return n(this.$pinia)[e](...t)},t),{}):Object.keys(i).reduce((t,e)=>(t[e]=function(...t){return n(this.$pinia)[i[e]](...t)},t),{})},O.mapGetters=e,O.mapState=t,O.mapStores=function(...t){return t.reduce((t,e)=>(t[e.$id+i]=function(){return e(this.$pinia)},t),{})},O.mapWritableState=function(n,i){return Array.isArray(i)?i.reduce((t,e)=>(t[e]={get(){return n(this.$pinia)[e]},set(t){return n(this.$pinia)[e]=t}},t),{}):Object.keys(i).reduce((t,e)=>(t[e]={get(){return n(this.$pinia)[i[e]]},set(t){return n(this.$pinia)[i[e]]=t}},t),{})},O.setActivePinia=S,O.setMapStoreSuffix=function(t){i=t},O.skipHydrate=function(t){return R.isVue2?T.set(t,1)&&t:Object.defineProperty(t,A,{})},O.storeToRefs=function(t){if(R.isVue2)return R.toRefs(t);{const n={};for(const i in t=R.toRaw(t)){var e=t[i];(R.isRef(e)||R.isReactive(e))&&(n[i]=R.toRef(t,i))}return n}},O}({},VueDemi);